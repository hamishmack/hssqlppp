{-

This file contains the syntax for sql select expressions and sub nodes.

It uses uuagc:

* http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
* http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

To compile use
uuagc  -dcfwsp --cycle --genlinepragmas AstInternal.ag

The attr and sem definitions are in separate files under the
./TypeChecking folder.

The ast nodes are parameterised on the annotation type, they double as
the parse tree and the ast, so are a bit of a compromise.


A select expression consists of the following rough areas:

top level - QueryExpression, one of:

* select expression
* table expression (not yet coded?)
* combined select (union, intersect, etc.)
* values expression
* cte expression

select lists (the bit between select and from)

table refs (the from bit)

where, group by, having

order by, limit, offset

scalar expressions



uuagc TYPEs and DATAs are used where we need to attach attr and sem
rules, otherwise regular haskell definitions are used.


PATH=$PATH:/home/jake/.cabal/bin/ uuagc  -dcfwsp --cycle --genlinepragmas -P /home/jake/wd/hssqlppp/selects/src/Database/HsSqlPpp/AstInternals/ /home/jake/wd/hssqlppp/selects/src/Database/HsSqlPpp/AstInternals/AstInternal.ag
-}

MODULE {Database.HsSqlPpp.AstInternals.AstInternal}
{
    -- {-# LANGUAGE DeriveDataTypeable,RankNTypes,ScopedTypeVariables #-}
    QueryExpression(..)
   ,WithQueryList
   ,WithQuery(..)
   ,CombineType(..)
   ,Direction(..)
   ,Distinct(..)

   ,SelectList(..)
   ,SelectItem(..)

   ,TableRef(..)
   ,TableAlias(..)
   ,JoinExpression(..)
   ,JoinType(..)
   ,Natural(..)

   ,ScalarExpression(..)
   ,LiftFlavour(..)
   ,InList(..)
   ,FrameClause(..)
   ,TypeName(..)

   ,SelectItemList
   ,TableRefList
   ,MaybeExpression
   ,MaybeBoolExpression
   ,OnExpr
   ,ExpressionList
   ,ExpressionListList
   ,ExpressionDirectionPair
   ,ExpressionDirectionPairList
   ,CaseExpressionListExpressionPair
   ,CaseExpressionListExpressionPairList

   ,typeCheckScalarExpr
   ,typeCheckQueryExpr
   ,typeCheckQueryExprs

   ,canonicaliseIdentifiers
}

{
import Data.Maybe
import Data.List
import Control.Applicative
import Data.Generics
import Data.Char
import Control.Monad.State

import Data.Generics.PlateData
import Debug.Trace

import Database.HsSqlPpp.AstInternals.TypeType
import Database.HsSqlPpp.AstInternals.TypeChecking.TypeConversion
import Database.HsSqlPpp.AstInternals.AstAnnotation
import Database.HsSqlPpp.AstInternals.Catalog.CatalogInternal
--import Database.HsSqlPpp.AstInternals.TypeChecking.LocalBindings
import Database.HsSqlPpp.Utils.Utils
--import Database.HsSqlPpp.AstInternals.TypeChecking.ErrorUtils

}

{-
--------------------------------------------------------------

== query expression

-}

DATA QueryExpression a
    | Select ann:{a}
             selDistinct : Distinct
             selSelectList : (SelectList {a})
             selTref : (TableRefList {a})
             selWhere : (MaybeBoolExpression {a})
             selGroupBy : (ExpressionList {a})
             selHaving : (MaybeBoolExpression {a})
             selOrderBy : (ExpressionDirectionPairList {a})
             selLimit : (MaybeExpression {a})
             selOffset : (MaybeExpression {a})
    | CombineSelect ann:{a}
                    ctype : CombineType
                    sel1 : (QueryExpression {a})
                    sel2 : (QueryExpression {a})
    | Values ann:{a}
             vll:(ExpressionListList {a})
    | WithSelect ann : {a}
                 withs : (WithQueryList {a})
                 ex : (QueryExpression {a})

DATA WithQuery a | WithQuery ann : {a}
                             name : String
                             ex : (QueryExpression{a})
{
data CombineType = Except | Union | Intersect | UnionAll
                   deriving (Show,Eq,Typeable,Data)

data Direction = Asc | Desc
                 deriving (Show,Eq,Typeable,Data)

data Distinct = Distinct | Dupes
                deriving (Show,Eq,Typeable,Data)
}

{-
-------------------------------------------------------------------------
= select lists
-}
DATA SelectList a | SelectList ann:{a} items:(SelectItemList{a})

DATA SelectItem a | SelExp ann:{a} ex:(ScalarExpression{a})
                  | SelectItem ann:{a} ex:(ScalarExpression{a}) name:String

{-
-------------------------------------------------------------------------
= Table refs
-}

DATA TableRef a | Tref ann:{a}
                       tbl : (ScalarExpression {a})
                       alias : TableAlias
                | JoinTref ann:{a}
                           tbl : (TableRef {a})
                           nat : Natural
                           joinType : JoinType
                           tbl1 : (TableRef {a})
                           onExpr : (OnExpr {a})
                           alias : TableAlias
                | SubTref ann:{a}
                          sel : (QueryExpression {a})
                          alias : TableAlias
                | FunTref ann:{a}
                          fn: (ScalarExpression {a})
                          alias : TableAlias


{
data TableAlias = NoAlias
                | TableAlias String --alias:String
                | FullAlias String [String] -- alias:String cols:{[String]}
                  deriving (Show,Eq,Typeable,Data)
}

DATA JoinExpression a | JoinOn ann:{a} expr:(ScalarExpression {a})
                      | JoinUsing ann:{a} x:{[String]}

{

data JoinType = Inner | LeftOuter| RightOuter | FullOuter | Cross
                deriving (Show,Eq,Typeable,Data)

data Natural = Natural | Unnatural
               deriving (Show,Eq,Typeable,Data)

}

{-
-------------------------------------------------------------------------
= scalar expressions
-}

DATA ScalarExpression a | IntegerLit ann:{a} i:Integer
                        | FloatLit ann:{a} d:Double
                        | StringLit ann:{a}
                                    value : String
                        | NullLit ann:{a}
                        | BooleanLit ann:{a} b:Bool
                        | PositionalArg ann:{a} p:Integer
                        | Placeholder ann:{a} -- represents a '?'
                        | Cast ann:{a}
                               expr:(ScalarExpression {a})
                               tn:(TypeName {a})
                        | Identifier ann:{a}
                                     i:String
                        | QIdentifier ann:{a}
                                      qual:(ScalarExpression {a})
                                      i:String
                        | Case ann:{a}
                               cases : (CaseExpressionListExpressionPairList {a})
                               els : (MaybeExpression {a})
                        | CaseSimple ann:{a}
                                     value : (ScalarExpression {a})
                                     cases : (CaseExpressionListExpressionPairList {a})
                                     els : (MaybeExpression {a})
                        | Exists ann:{a}
                                 sel : (QueryExpression {a})
                        | FunCall ann:{a}
                                  funName:String
                                  args:(ExpressionList {a})
                        | InPredicate ann:{a}
                                      expr:(ScalarExpression {a})
                                      i:Bool
                                      list:(InList {a})
                        | WindowFn ann:{a}
                                   fn : (ScalarExpression {a})
                                   partitionBy : (ExpressionList {a})
                                   orderBy : (ExpressionList {a})
                                   dir : Direction
                                   frm : FrameClause
                        | ScalarSubQuery ann:{a}
                                         sel : (QueryExpression {a})
                        | LiftOperator ann : {a}
                                       oper : String
                                       flav : LiftFlavour
                                       args : (ExpressionList {a})
{
data LiftFlavour = LiftAny | LiftAll
                   deriving (Show,Eq,Typeable,Data)
}

--todo: use liftoperator to implement inlist?
DATA InList a | InList ann:{a} exprs : (ExpressionList {a})
              | InSelect ann:{a} sel : (QueryExpression {a})

{
data FrameClause = FrameUnboundedPreceding
                 | FrameUnboundedFull
                 | FrameRowsUnboundedPreceding
                   deriving (Show,Eq,Typeable,Data)
}


DATA TypeName a | SimpleTypeName ann:{a} tn:String
                | PrecTypeName ann:{a} tn:String prec:Integer
                | ArrayTypeName ann:{a} typ:(TypeName {a})
                | SetOfTypeName ann:{a} typ:(TypeName {a})


-------------------------------------------------------------------------
{-
= type checking
-}

{

typeCheckScalarExpr :: Catalog -> ScalarExpression SourcePosition -> ScalarExpression Annotation
typeCheckScalarExpr = undefined

typeCheckQueryExpr :: Catalog -> QueryExpression SourcePosition -> QueryExpression Annotation
typeCheckQueryExpr = undefined

typeCheckQueryExprs :: Catalog -> [QueryExpression SourcePosition] -> [QueryExpression Annotation]
typeCheckQueryExprs = undefined

}

INCLUDE "TypeChecking/CanonicaliseIdentifiers.ag"

-------------------------------------------------------------------------
{-
= some boilerplate
-}

TYPE WithQueryList a = [(WithQuery {a})]

TYPE SelectItemList a = [(SelectItem {a})]

TYPE TableRefList a = [(TableRef {a})]

TYPE MaybeExpression a = MAYBE {ScalarExpression a}
TYPE MaybeBoolExpression a = MAYBE {ScalarExpression a}
TYPE OnExpr a = MAYBE {JoinExpression a}

TYPE ExpressionList a = [(ScalarExpression {a})]
TYPE ExpressionListList a = [(ExpressionList {a})]

TYPE ExpressionDirectionPair a = ((ScalarExpression {a}),Direction)
TYPE ExpressionDirectionPairList a = [(ExpressionDirectionPair {a})]

TYPE CaseExpressionListExpressionPair a = ((ExpressionList {a}),(ScalarExpression {a}))
TYPE CaseExpressionListExpressionPairList a = [(CaseExpressionListExpressionPair {a})]

SET AllNodes = QueryExpression WithQuery
               TableRef JoinExpression
               SelectList SelectItem
               ScalarExpression
               InList TypeName
               WithQueryList SelectItemList TableRefList
               MaybeExpression MaybeBoolExpression OnExpr
               ExpressionList ExpressionListList
               ExpressionDirectionPair ExpressionDirectionPairList
               CaseExpressionListExpressionPair CaseExpressionListExpressionPairList

DERIVING AllNodes: Show,Eq,Typeable,Data

DATA Root a | Root expr: {[QueryExpression a]}
DERIVING Root: Show
