{-

This is the code to canonicalise the identifiers.

Basically, this adds range qualifiers to all identifiers where it
makes sense. We don't do any errors at this stage, so ambiguous and
unrecognised identifiers are left as is for the type checking phase to
deal with. This is mainly so we don't change the type of the
annotation on the tree.

In addition, star expansion (only when referred to at top level select
list or equivalent, count(*) and other stars are left for the type
checker) is done here. If e.g. order by 3,1 like syntax is needed,
then this can be fixed up here also.

We need the the sources of identifiers from the catalog: tables,
views, functions.

Identifiers are added to the environment only in table refs (I think
there are a few more places, e.g. refering to the name of a column in
a select list in a order by or similar, these aren't currently
supported, need to get a comprehensive list of these first).

Identifiers are qualified straightforwardly in:

select lists
wheres
group bys
havings
order bys

All of the above use the same environment which comes out of the top
level trefs in a statement.

Identifiers in on expressions in joins need to be fixed up also, they
use an environment which is local to that join.

Identifiers in a using join aren't changed, since they refer to either
table.

How exactly is the environment updated?

Vanilla tref, subtref and trefun all set the exact environment.

For joins: the two environments are combined (this goes into the
onexpr). If there is a table name alias, then the aliases are
replaced. If there are column aliases as well, then the whole lot gets
replaced with these.

===================================================

= environment: data type, read api, update api

-}

{

data Environment = Environment Int

qualifyID :: Environment -> String -> (Maybe String,String)
qualifyID = undefined

makeEnvironment :: String -- range qualifier
                -> [String] -- attribute names
                -> Environment
makeEnvironment = undefined

emptyEnvironment :: Environment
emptyEnvironment = undefined

unimplementedEnvironment :: Environment
unimplementedEnvironment = undefined


joinEnvironments :: Environment -> Environment -> Environment
joinEnvironments = undefined

aliasEnvironmentRangeName :: Environment -> String -> Environment
aliasEnvironmentRangeName = undefined

expandStar :: Environment -> Maybe String --qualifier
           -> [String]
expandStar = undefined

}

{-

= Creating environments

environments are created in trefs, and also select lists (to support
subtref).

-}

ATTR TableRef SelectList
         [
         |
         | cenv : Environment
         ]

SEM TableRef
    | Tref loc.fields = getTableFields @tbl
      JoinTref SubTref FunTref lhs.cenv = unimplementedEnvironment

SEM SelectList
    | SelectList lhs.cenv = unimplementedEnvironment

{
getTableFields :: ScalarExpression a -> [String]
getTableFields = undefined
}

{-

= Passing environments around

Passing up:
* through nested trefs
* from trefs to selects
* from select lists -> select -> wrapping subtref
-}

ATTR TableRefList QueryExpression
         [
         |
         | cenv : Environment
         ]

SEM TableRefList
    | Cons lhs.cenv = joinEnvironments @hd.cenv @tl.cenv
    | Nil lhs.cenv = emptyEnvironment

SEM QueryExpression
    | Select lhs.cenv = @selSelectList.cenv
    | CombineSelect lhs.cenv = @sel1.cenv
    | Values lhs.cenv = unimplementedEnvironment
    | WithSelect lhs.cenv = @ex.cenv


{-

== Passing down

* from jointref to onexpr
* from select to (select list, where, group by, having, order by
* through scalar expression trees

-}

ATTR OnExpr JoinExpression ScalarExpression
         [ env : Environment
         |
         |
         ]

SEM TableRef
    | JoinTref onExpr.env = unimplementedEnvironment


-- this is where the environment from the top level tref in a query
-- expression is sent back down into the select list, where, etc.

SEM QueryExpression
    | Select selSelectList.env = @selTref.cenv
             selWhere.env = @selTref.cenv
             selGroupBy.env = @selTref.cenv
             selHaving.env = @selTref.cenv
             selOrderBy.env = @selTref.cenv

{-

= Accessing environments

Environment is used to fix up identifiers in scalar expressions.

For adding qualifiers, all the identifiers in a scalar expression are
updated the same.

The roots are:
Select.selSelectList -> SelectItemList -> (SelEx,SelectItem).ex
Select.selWhere MaybeBoolExpression
Select.selGroupBy -> ExpressionList
Select.selHaving -> MaybeBoolExpression
Select.setOrdereBy -> ExpressionDirectionPairList
JoinedTref.onExpr

-}

{



}

ATTR Root AllNodes [ cat : Catalog
                   |
                   | canonicalisedIdentifiersTree : SELF
                   ]

{
canonicaliseIdentifiers :: Catalog -> [QueryExpression a] -> [QueryExpression a]
canonicaliseIdentifiers cat sts =
    let t = sem_Root (Root sts)
        ta = wrap_Root t Inh_Root {cat_Inh_Root = cat}
        tl = canonicalisedIdentifiersTree_Syn_Root ta
    in case tl of
         Root r -> r

}
